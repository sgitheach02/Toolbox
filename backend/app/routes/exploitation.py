# backend/app/routes/exploitation.py
from flask import Blueprint, request, jsonify
import subprocess
import uuid
import os
import threading
import json
import requests
import socket
from datetime import datetime
import logging
import re
import base64

exploit_bp = Blueprint("exploitation", __name__)
logger = logging.getLogger(__name__)

# Configuration des outils d'exploitation
EXPLOIT_TOOLS = {
    'metasploit': {
        'enabled': False,  # D√©sactiv√© par d√©faut pour la s√©curit√©
        'timeout': 300,
        'msfconsole_path': '/usr/bin/msfconsole'
    },
    'sqlmap': {
        'enabled': True,
        'timeout': 600,
        'binary': 'sqlmap'
    },
    'nikto': {
        'enabled': True,
        'timeout': 300,
        'binary': 'nikto'
    },
    'dirb': {
        'enabled': True,
        'timeout': 180,
        'binary': 'dirb'
    }
}

# Stockage des t√¢ches d'exploitation
exploit_tasks = {}

def create_exploit_task(task_type, data):
    """Cr√©ation d'une t√¢che d'exploitation"""
    task_id = str(uuid.uuid4())
    task = {
        'id': task_id,
        'type': task_type,
        'status': 'created',
        'created_at': datetime.now().isoformat(),
        'data': data,
        'result': None,
        'error': None,
        'risk_level': 'medium'
    }
    exploit_tasks[task_id] = task
    logger.info(f"‚ö†Ô∏è T√¢che exploitation cr√©√©e: {task_id} ({task_type})")
    return task_id

def update_exploit_task_status(task_id, status, result=None, error=None):
    """Mise √† jour du statut d'une t√¢che d'exploitation"""
    if task_id in exploit_tasks:
        exploit_tasks[task_id]['status'] = status
        exploit_tasks[task_id]['updated_at'] = datetime.now().isoformat()
        if result:
            exploit_tasks[task_id]['result'] = result
        if error:
            exploit_tasks[task_id]['error'] = error
        logger.info(f"‚ö†Ô∏è T√¢che exploitation {task_id}: {status}")

def validate_target_for_exploitation(target):
    """Validation stricte des cibles pour l'exploitation"""
    if not target:
        return False
    
    # Cibles autoris√©es UNIQUEMENT pour les tests d'intrusion l√©gaux
    allowed_targets = [
        '127.0.0.1', 'localhost',
        'testphp.vulnweb.com',
        'demo.testfire.net',
        'zero.webappsecurity.com',
        'dvwa.local',
        'metasploitable.local'
    ]
    
    # Plages IP de test autoris√©es
    allowed_ranges = [
        '192.168.', '172.16.', '172.17.', '172.18.', '172.19.', '172.20.',
        '10.0.', '10.1.', '10.2.'
    ]
    
    # V√©rification directe
    if target in allowed_targets:
        return True
    
    # V√©rification des plages de test
    for range_prefix in allowed_ranges:
        if target.startswith(range_prefix):
            return True
    
    logger.warning(f"üö´ Cible non autoris√©e pour exploitation: {target}")
    return False

def perform_web_vulnerability_scan(target, task_id):
    """Scan de vuln√©rabilit√©s web avec Nikto"""
    try:
        update_exploit_task_status(task_id, 'running')
        
        logger.info(f"üï∑Ô∏è Scan web vulnerabilities pour: {target}")
        
        # Construction de l'URL si n√©cessaire
        if not target.startswith(('http://', 'https://')):
            target_url = f"http://{target}"
        else:
            target_url = target
        
        # Commande Nikto
        cmd = [
            'nikto',
            '-h', target_url,
            '-Format', 'json',
            '-output', f'/app/reports/nikto_scan_{task_id}.json'
        ]
        
        logger.info(f"üï∑Ô∏è Commande Nikto: {' '.join(cmd)}")
        
        # Ex√©cution avec timeout
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=EXPLOIT_TOOLS['nikto']['timeout']
        )
        
        # Parsing des r√©sultats
        vulnerabilities = []
        if result.stdout:
            lines = result.stdout.split('\n')
            for line in lines:
                if '+ ' in line and ('OSVDB' in line or 'CVE' in line or 'vulnerability' in line.lower()):
                    vulnerabilities.append(line.strip())
        
        # Analyse des vuln√©rabilit√©s trouv√©es
        high_risk_patterns = ['sql injection', 'xss', 'rfi', 'lfi', 'code execution']
        medium_risk_patterns = ['directory traversal', 'information disclosure', 'weak password']
        
        risk_analysis = {
            'high_risk': [],
            'medium_risk': [],
            'low_risk': [],
            'info': []
        }
        
        for vuln in vulnerabilities:
            vuln_lower = vuln.lower()
            if any(pattern in vuln_lower for pattern in high_risk_patterns):
                risk_analysis['high_risk'].append(vuln)
            elif any(pattern in vuln_lower for pattern in medium_risk_patterns):
                risk_analysis['medium_risk'].append(vuln)
            else:
                risk_analysis['low_risk'].append(vuln)
        
        result_data = {
            'target': target_url,
            'tool': 'nikto',
            'vulnerabilities_found': len(vulnerabilities),
            'risk_analysis': risk_analysis,
            'raw_output': result.stdout,
            'command': ' '.join(cmd)
        }
        
        # Sauvegarde du rapport d√©taill√©
        report_file = f"/app/reports/web_vuln_scan_{task_id}.json"
        with open(report_file, 'w') as f:
            json.dump(result_data, f, indent=2)
        
        result_data['report_file'] = report_file
        
        update_exploit_task_status(task_id, 'completed', result_data)
        logger.info(f"‚úÖ Scan web vuln√©rabilit√©s termin√©: {task_id}")
        
    except subprocess.TimeoutExpired:
        update_exploit_task_status(task_id, 'timeout', error="Timeout d√©pass√©")
        logger.error(f"‚è∞ Timeout scan web: {task_id}")
    except Exception as e:
        error_msg = f"Erreur scan web: {str(e)}"
        update_exploit_task_status(task_id, 'failed', error=error_msg)
        logger.error(f"‚ùå Erreur scan web: {e}")

def perform_sql_injection_test(target, task_id):
    """Test d'injection SQL avec SQLMap"""
    try:
        update_exploit_task_status(task_id, 'running')
        
        logger.info(f"üíâ Test injection SQL pour: {target}")
        
        # Construction de l'URL si n√©cessaire
        if not target.startswith(('http://', 'https://')):
            target_url = f"http://{target}"
        else:
            target_url = target
        
        # Commande SQLMap avec options s√©curis√©es
        cmd = [
            'sqlmap',
            '-u', target_url,
            '--batch',  # Mode non-interactif
            '--crawl=1',  # Crawl limit√©
            '--level=1',  # Level de test basique
            '--risk=1',   # Risque minimal
            '--timeout=10',
            '--retries=1',
            '--technique=B',  # Boolean-based blind uniquement
            '--no-cast',
            '--skip-urlencode',
            '--output-dir=/app/reports/',
            '--format=JSON'
        ]
        
        logger.info(f"üíâ Commande SQLMap: {' '.join(cmd)}")
        
        # Ex√©cution avec timeout strict
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=EXPLOIT_TOOLS['sqlmap']['timeout']
        )
        
        # Analyse des r√©sultats
        sql_vulnerabilities = []
        if result.stdout:
            if 'vulnerable' in result.stdout.lower():
                # Extraction des vuln√©rabilit√©s d√©tect√©es
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'Parameter:' in line or 'Type:' in line or 'Payload:' in line:
                        sql_vulnerabilities.append(line.strip())
        
        result_data = {
            'target': target_url,
            'tool': 'sqlmap',
            'vulnerabilities_found': len(sql_vulnerabilities),
            'sql_injection_detected': len(sql_vulnerabilities) > 0,
            'vulnerabilities': sql_vulnerabilities,
            'raw_output': result.stdout[:2000],  # Limit√© pour s√©curit√©
            'command': ' '.join(cmd),
            'risk_assessment': 'HIGH' if sql_vulnerabilities else 'LOW'
        }
        
        # Sauvegarde du rapport
        report_file = f"/app/reports/sql_injection_test_{task_id}.json"
        with open(report_file, 'w') as f:
            json.dump(result_data, f, indent=2)
        
        result_data['report_file'] = report_file
        
        update_exploit_task_status(task_id, 'completed', result_data)
        logger.info(f"‚úÖ Test injection SQL termin√©: {task_id}")
        
    except subprocess.TimeoutExpired:
        update_exploit_task_status(task_id, 'timeout', error="Timeout d√©pass√©")
        logger.error(f"‚è∞ Timeout SQLMap: {task_id}")
    except Exception as e:
        error_msg = f"Erreur test SQL injection: {str(e)}"
        update_exploit_task_status(task_id, 'failed', error=error_msg)
        logger.error(f"‚ùå Erreur SQLMap: {e}")

def perform_directory_enumeration(target, task_id):
    """√ânum√©ration de r√©pertoires avec DIRB"""
    try:
        update_exploit_task_status(task_id, 'running')
        
        logger.info(f"üìÅ √ânum√©ration r√©pertoires pour: {target}")
        
        # Construction de l'URL si n√©cessaire
        if not target.startswith(('http://', 'https://')):
            target_url = f"http://{target}"
        else:
            target_url = target
        
        # Wordlist commune pour DIRB
        wordlist = '/usr/share/wordlists/dirb/common.txt'
        if not os.path.exists(wordlist):
            wordlist = '/usr/share/dirb/wordlists/common.txt'
        
        # Commande DIRB
        cmd = [
            'dirb',
            target_url,
            wordlist,
            '-o', f'/app/reports/dirb_scan_{task_id}.txt',
            '-w',  # Ne pas arr√™ter sur les warnings
            '-r',  # Non-r√©cursif pour la s√©curit√©
            '-S'   # Silent mode partiel
        ]
        
        logger.info(f"üìÅ Commande DIRB: {' '.join(cmd)}")
        
        # Ex√©cution avec timeout
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=EXPLOIT_TOOLS['dirb']['timeout']
        )
        
        # Parsing des r√©sultats
        found_directories = []
        found_files = []
        
        if result.stdout:
            lines = result.stdout.split('\n')
            for line in lines:
                if '+ ' in line and 'http' in line:
                    url_match = re.search(r'http[s]?://[^\s]+', line)
                    if url_match:
                        found_url = url_match.group()
                        if found_url.endswith('/'):
                            found_directories.append(found_url)
                        else:
                            found_files.append(found_url)
        
        # Analyse des d√©couvertes sensibles
        sensitive_patterns = [
            'admin', 'login', 'config', 'backup', 'test', 'dev',
            'phpmyadmin', 'wp-admin', 'manager', 'console'
        ]
        
        sensitive_findings = []
        for item in found_directories + found_files:
            for pattern in sensitive_patterns:
                if pattern in item.lower():
                    sensitive_findings.append(item)
                    break
        
        result_data = {
            'target': target_url,
            'tool': 'dirb',
            'directories_found': len(found_directories),
            'files_found': len(found_files),
            'sensitive_findings': len(sensitive_findings),
            'directories': found_directories,
            'files': found_files,
            'sensitive_items': sensitive_findings,
            'total_items': len(found_directories) + len(found_files),
            'command': ' '.join(cmd)
        }
        
        # Sauvegarde du rapport
        report_file = f"/app/reports/directory_enum_{task_id}.json"
        with open(report_file, 'w') as f:
            json.dump(result_data, f, indent=2)
        
        result_data['report_file'] = report_file
        
        update_exploit_task_status(task_id, 'completed', result_data)
        logger.info(f"‚úÖ √ânum√©ration r√©pertoires termin√©e: {task_id}")
        
    except subprocess.TimeoutExpired:
        update_exploit_task_status(task_id, 'timeout', error="Timeout d√©pass√©")
        logger.error(f"‚è∞ Timeout DIRB: {task_id}")
    except Exception as e:
        error_msg = f"Erreur √©num√©ration r√©pertoires: {str(e)}"
        update_exploit_task_status(task_id, 'failed', error=error_msg)
        logger.error(f"‚ùå Erreur DIRB: {e}")

def perform_comprehensive_web_attack(target, task_id):
    """Attaque web compl√®te combinant plusieurs outils"""
    try:
        update_exploit_task_status(task_id, 'running')
        
        logger.info(f"üéØ Attaque web compl√®te pour: {target}")
        
        result = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'nikto_results': None,
            'dirb_results': None,
            'manual_tests': None,
            'summary': {},
            'risk_assessment': 'LOW'
        }
        
        # Construction de l'URL
        if not target.startswith(('http://', 'https://')):
            target_url = f"http://{target}"
        else:
            target_url = target
        
        # 1. Scan Nikto rapide
        try:
            cmd_nikto = ['nikto', '-h', target_url, '-maxtime', '60']
            nikto_result = subprocess.run(cmd_nikto, capture_output=True, text=True, timeout=120)
            
            vulnerabilities = []
            if nikto_result.stdout:
                lines = nikto_result.stdout.split('\n')
                for line in lines:
                    if '+ ' in line and any(risk in line.lower() for risk in ['osvdb', 'cve', 'vuln']):
                        vulnerabilities.append(line.strip())
            
            result['nikto_results'] = {
                'vulnerabilities': vulnerabilities,
                'count': len(vulnerabilities)
            }
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erreur Nikto: {e}")
        
        # 2. √ânum√©ration rapide des r√©pertoires
        try:
            # Test manuel de r√©pertoires communs
            common_dirs = [
                'admin', 'login', 'config', 'backup', 'test',
                'phpmyadmin', 'wp-admin', 'manager', 'console'
            ]
            
            accessible_dirs = []
            for directory in common_dirs:
                try:
                    test_url = f"{target_url}/{directory}"
                    response = requests.get(test_url, timeout=5)
                    if response.status_code not in [404, 403]:
                        accessible_dirs.append({
                            'url': test_url,
                            'status_code': response.status_code,
                            'content_length': len(response.content)
                        })
                except:
                    pass
            
            result['dirb_results'] = {
                'accessible_directories': accessible_dirs,
                'count': len(accessible_dirs)
            }
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erreur √©num√©ration manuelle: {e}")
        
        # 3. Tests manuels basiques
        try:
            manual_tests = []
            
            # Test de la page principale
            try:
                response = requests.get(target_url, timeout=10)
                headers_analysis = {
                    'server': response.headers.get('Server', 'Unknown'),
                    'x_powered_by': response.headers.get('X-Powered-By', 'Unknown'),
                    'security_headers': {
                        'x_frame_options': 'X-Frame-Options' in response.headers,
                        'x_xss_protection': 'X-XSS-Protection' in response.headers,
                        'x_content_type_options': 'X-Content-Type-Options' in response.headers
                    }
                }
                manual_tests.append(headers_analysis)
            except:
                pass
            
            result['manual_tests'] = manual_tests
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erreur tests manuels: {e}")
        
        # 4. √âvaluation des risques
        risk_score = 0
        if result['nikto_results'] and result['nikto_results']['count'] > 0:
            risk_score += result['nikto_results']['count'] * 2
        if result['dirb_results'] and result['dirb_results']['count'] > 0:
            risk_score += result['dirb_results']['count']
        
        if risk_score > 10:
            result['risk_assessment'] = 'HIGH'
        elif risk_score > 5:
            result['risk_assessment'] = 'MEDIUM'
        else:
            result['risk_assessment'] = 'LOW'
        
        result['summary'] = {
            'total_vulnerabilities': (result['nikto_results']['count'] if result['nikto_results'] else 0),
            'accessible_dirs': (result['dirb_results']['count'] if result['dirb_results'] else 0),
            'risk_score': risk_score,
            'risk_level': result['risk_assessment']
        }
        
        # Sauvegarde du rapport
        report_file = f"/app/reports/comprehensive_web_attack_{task_id}.json"
        with open(report_file, 'w') as f:
            json.dump(result, f, indent=2, default=str)
        
        result['report_file'] = report_file
        
        update_exploit_task_status(task_id, 'completed', result)
        logger.info(f"‚úÖ Attaque web compl√®te termin√©e: {task_id}")
        
    except Exception as e:
        error_msg = f"Erreur attaque web compl√®te: {str(e)}"
        update_exploit_task_status(task_id, 'failed', error=error_msg)
        logger.error(f"‚ùå Erreur attaque compl√®te: {e}")

# Routes de l'API d'exploitation
@exploit_bp.route("/test", methods=["GET"])
def test_exploit():
    """Test du module d'exploitation"""
    return jsonify({
        "message": "‚ö†Ô∏è Module exploitation fonctionnel !",
        "version": "1.0",
        "warning": "USAGE AUTORIS√â UNIQUEMENT SUR VOS SYST√àMES OU AVEC AUTORISATION EXPLICITE",
        "available_endpoints": [
            "/api/exploit/web-scan",
            "/api/exploit/sql-injection",
            "/api/exploit/directory-enum", 
            "/api/exploit/comprehensive",
            "/api/exploit/status/<task_id>",
            "/api/exploit/tasks"
        ],
        "tools_status": EXPLOIT_TOOLS
    })

@exploit_bp.route("/web-scan", methods=["POST"])
def start_web_vulnerability_scan():
    """D√©marrage d'un scan de vuln√©rabilit√©s web"""
    try:
        data = request.get_json()
        
        if not data or 'target' not in data:
            return jsonify({"error": "Param√®tre 'target' requis"}), 400
        
        target = data['target'].strip()
        
        if not validate_target_for_exploitation(target):
            return jsonify({
                "error": "Cible non autoris√©e pour exploitation",
                "warning": "Tests d'intrusion autoris√©s uniquement sur vos syst√®mes"
            }), 403
        
        # Cr√©ation de la t√¢che
        task_id = create_exploit_task('web_vulnerability_scan', {
            'target': target,
            'started_at': datetime.now().isoformat()
        })
        
        # Lancement en arri√®re-plan
        thread = threading.Thread(target=perform_web_vulnerability_scan, args=(target, task_id))
        thread.daemon = True
        thread.start()
        
        return jsonify({
            "task_id": task_id,
            "status": "started",
            "target": target,
            "message": "Scan de vuln√©rabilit√©s web d√©marr√©",
            "warning": "Test autoris√© uniquement sur vos syst√®mes"
        })
        
    except Exception as e:
        logger.error(f"‚ùå Erreur d√©marrage web scan: {e}")
        return jsonify({"error": str(e)}), 500

@exploit_bp.route("/sql-injection", methods=["POST"])
def start_sql_injection_test():
    """D√©marrage d'un test d'injection SQL"""
    try:
        data = request.get_json()
        
        if not data or 'target' not in data:
            return jsonify({"error": "Param√®tre 'target' requis"}), 400
        
        target = data['target'].strip()
        
        if not validate_target_for_exploitation(target):
            return jsonify({
                "error": "Cible non autoris√©e pour exploitation",
                "warning": "Tests d'intrusion autoris√©s uniquement sur vos syst√®mes"
            }), 403
        
        # Cr√©ation de la t√¢che
        task_id = create_exploit_task('sql_injection_test', {
            'target': target,
            'started_at': datetime.now().isoformat()
        })
        
        # Lancement en arri√®re-plan
        thread = threading.Thread(target=perform_sql_injection_test, args=(target, task_id))
        thread.daemon = True
        thread.start()
        
        return jsonify({
            "task_id": task_id,
            "status": "started",
            "target": target,
            "message": "Test d'injection SQL d√©marr√©",
            "warning": "Test autoris√© uniquement sur vos syst√®mes"
        })
        
    except Exception as e:
        logger.error(f"‚ùå Erreur d√©marrage SQL injection: {e}")
        return jsonify({"error": str(e)}), 500

@exploit_bp.route("/directory-enum", methods=["POST"])
def start_directory_enumeration():
    """D√©marrage d'une √©num√©ration de r√©pertoires"""
    try:
        data = request.get_json()
        
        if not data or 'target' not in data:
            return jsonify({"error": "Param√®tre 'target' requis"}), 400
        
        target = data['target'].strip()
        
        if not validate_target_for_exploitation(target):
            return jsonify({
                "error": "Cible non autoris√©e pour exploitation",
                "warning": "Tests d'intrusion autoris√©s uniquement sur vos syst√®mes"
            }), 403
        
        # Cr√©ation de la t√¢che
        task_id = create_exploit_task('directory_enumeration', {
            'target': target,
            'started_at': datetime.now().isoformat()
        })
        
        # Lancement en arri√®re-plan
        thread = threading.Thread(target=perform_directory_enumeration, args=(target, task_id))
        thread.daemon = True
        thread.start()
        
        return jsonify({
            "task_id": task_id,
            "status": "started",
            "target": target,
            "message": "√ânum√©ration de r√©pertoires d√©marr√©e",
            "warning": "Test autoris√© uniquement sur vos syst√®mes"
        })
        
    except Exception as e:
        logger.error(f"‚ùå Erreur d√©marrage directory enum: {e}")
        return jsonify({"error": str(e)}), 500

@exploit_bp.route("/comprehensive", methods=["POST"])
def start_comprehensive_web_attack():
    """D√©marrage d'une attaque web compl√®te"""
    try:
        data = request.get_json()
        
        if not data or 'target' not in data:
            return jsonify({"error": "Param√®tre 'target' requis"}), 400
        
        target = data['target'].strip()
        
        if not validate_target_for_exploitation(target):
            return jsonify({
                "error": "Cible non autoris√©e pour exploitation",
                "warning": "Tests d'intrusion autoris√©s uniquement sur vos syst√®mes"
            }), 403
        
        # Cr√©ation de la t√¢che
        task_id = create_exploit_task('comprehensive_web_attack', {
            'target': target,
            'started_at': datetime.now().isoformat()
        })
        
        # Lancement en arri√®re-plan
        thread = threading.Thread(target=perform_comprehensive_web_attack, args=(target, task_id))
        thread.daemon = True
        thread.start()
        
        return jsonify({
            "task_id": task_id,
            "status": "started",
            "target": target,
            "message": "Attaque web compl√®te d√©marr√©e",
            "warning": "Test autoris√© uniquement sur vos syst√®mes"
        })
        
    except Exception as e:
        logger.error(f"‚ùå Erreur d√©marrage attaque compl√®te: {e}")
        return jsonify({"error": str(e)}), 500

@exploit_bp.route("/status/<task_id>", methods=["GET"])
def get_exploit_task_status(task_id):
    """R√©cup√©ration du statut d'une t√¢che d'exploitation"""
    if task_id not in exploit_tasks:
        return jsonify({"error": "T√¢che non trouv√©e"}), 404
    
    task = exploit_tasks[task_id]
    return jsonify(task)

@exploit_bp.route("/tasks", methods=["GET"])
def list_exploit_tasks():
    """Liste de toutes les t√¢ches d'exploitation"""
    return jsonify({
        "total_tasks": len(exploit_tasks),
        "tasks": list(exploit_tasks.values()),
        "warning": "Toutes les t√¢ches doivent √™tre autoris√©es l√©galement"
    })

@exploit_bp.route("/tools", methods=["GET"])
def get_exploit_tools_status():
    """Status des outils d'exploitation"""
    return jsonify({
        "tools": EXPLOIT_TOOLS,
        "available_operations": [
            "web_vulnerability_scan",
            "sql_injection_test",
            "directory_enumeration",
            "comprehensive_web_attack"
        ],
        "security_notice": "Usage autoris√© uniquement sur vos syst√®mes ou avec autorisation explicite"
    })